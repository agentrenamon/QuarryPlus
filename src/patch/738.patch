--- a/com/yogpc/ip/BlockController.java
+++ b/com/yogpc/ip/BlockController.java
@@ -23,11 +26,16 @@
   public BlockController(final int id) {
     super(id, Material.circuits);
     setUnlocalizedName("spawnercontroller");
-    setTextureName("yogpstop_qp:spawnctl");
     setHardness(1.0f);
     setCreativeTab(CreativeTabs.tabRedstone);
   }
 
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:spawnctl");
+  }
+
   private static final MobSpawnerBaseLogic getSpawner(final World w, final int x, final int y,
       final int z) {
     for (final ForgeDirection d : ForgeDirection.VALID_DIRECTIONS) {
--- a/com/yogpc/ip/ItemArmorElectric.java
+++ b/com/yogpc/ip/ItemArmorElectric.java
@@ -26,20 +26,24 @@
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 
-public class ItemArmorElectric extends ItemArmor implements ISpecialArmor, IElectricItem,
-    IEnergyContainerItem {
+public class ItemArmorElectric extends ItemArmor implements ISpecialArmor, IElectricItem {
   public ItemArmorElectric(final int id) {
     super(id, EnumHelper.addArmorMaterial("ELECTRIC", 33, new int[] {3, 8, 6, 3}, 0), YogpstopLib.proxy
         .addNewArmourRendererPrefix("electric"), 1);
     setUnlocalizedName("electric_armor");
     setCreativeTab(CreativeTabs.tabCombat);
-    setTextureName("yogpstop_qp:elecArmor");
     setMaxDamage(100);
     setMaxStackSize(1);
   }
 
   @Override
-  public String getArmorTexture(final ItemStack i, final Entity e, final int s, final String t) {
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.itemIcon = ir.registerIcon("yogpstop_qp:elecArmor");
+  }
+
+  @Override
+  public String getArmorTexture(ItemStack i, Entity e, int s, int l) {
     return "yogpstop_qp:textures/models/armor/elecArmor_layer_1.png";
   }
 
@@ -188,25 +192,4 @@
   public int getTransferLimit(final ItemStack itemStack) {
     return 2500;
   }
-
-  @Override
-  public int extractEnergy(final ItemStack is, final int am, final boolean sim) {
-    return 0;
-  }
-
-  @Override
-  public int getEnergyStored(final ItemStack is) {
-    return (int) (ElectricItemManager.getCharge(is) * 4);
-  }
-
-  @Override
-  public int getMaxEnergyStored(final ItemStack is) {
-    return (int) (getMaxCharge(is) * 4);
-  }
-
-  @Override
-  public int receiveEnergy(final ItemStack is, final int am, final boolean sim) {
-    return (int) (ElectricItemManager.charge(is, Math.min((double) am / 4, getTransferLimit(is)),
-        getMaxCharge(is)) * 4);
-  }
 }
--- a/com/yogpc/ip/ItemMirror.java
+++ b/com/yogpc/ip/ItemMirror.java
@@ -17,11 +18,16 @@
   public ItemMirror(final int id) {
     super(id);
     setUnlocalizedName("magicmirror");
-    setTextureName("yogpstop_qp:mm");
     setCreativeTab(CreativeTabs.tabTools);
   }
 
   @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.itemIcon = ir.registerIcon("yogpstop_qp:mm");
+  }
+
+  @Override
   public ItemStack onEaten(final ItemStack i, final World w, final EntityPlayer p) {
     if (p instanceof EntityPlayerMP) {
       if (i.getItemDamage() != 0) {
--- a/com/yogpc/mc_lib/APowerTile.java
+++ b/com/yogpc/mc_lib/APowerTile.java
@@ -9,9 +9,8 @@
 import buildcraft.api.power.IPowerReceptor;
 import buildcraft.api.power.IPowerProvider;
 
-public abstract class APowerTile extends APacketTile implements IPowerReceptor, IEnergyHandler,
-    IEnergySink {
-  private final IPowerProvider pp = new IPowerProvider(this, Type.MACHINE);
+public abstract class APowerTile extends APacketTile implements IPowerReceptor, IEnergySink {
+  private final IPowerProvider pp = PowerFramework.currentFramework.createPowerProvider();
   private double all, maxGot, max, got;
 
   @Override
@@ -32,8 +31,13 @@
   public final void doWork() {}
 
   @Override
-  public final World getWorld() {
-    return this.worldObj;
+  public final int powerRequest(final ForgeDirection d) {
+    return (int) Math.ceil(Math.min(this.maxGot, this.max - this.all));
+  }
+
+  @Override
+  public final void setPowerProvider(final IPowerProvider p) {
+    return;
   }
 
   @Override
@@ -42,7 +46,7 @@
     this.all = nbttc.getDouble("storedEnergy");
     this.max = nbttc.getDouble("MAX_stored");
     this.maxGot = nbttc.getDouble("MAX_receive");
-    this.pp.configure(0, (float) this.maxGot, 0, (float) this.max);
+    this.pp.configure(0, 0, (int) this.maxGot, 0, (int) this.max);
   }
 
   @Override
@@ -86,32 +90,17 @@
   public final void configure(final double x, final double maxstored) {
     this.maxGot = x;
     this.max = maxstored;
-    this.pp.configure(0, (float) this.maxGot, 0, (float) this.max);
-  }
-
-  @Override
-  public int getEnergyStored(final ForgeDirection d) {
-    return (int) (this.all * 10);
-  }
-
-  @Override
-  public int getMaxEnergyStored(final ForgeDirection d) {
-    return (int) (this.max * 10);
-  }
-
-  @Override
-  public int receiveEnergy(final ForgeDirection d, final int am, final boolean sim) {
-    return (int) getEnergy((double) am / 10) * 10;
+    this.pp.configure(0, 0, (int) this.maxGot, 0, (int) this.max);
   }
 
   @Override
   public int demandsEnergy() {
-    return Math.min(this.maxGot - this.got, this.max - this.all - this.got) * 2.5;
+    return (int) (Math.min(this.maxGot - this.got, this.max - this.all - this.got) * 2.5);
   }
 
   @Override
   public int injectEnergy(final Direction d, final int am) {
-    return getEnergy(am / 2.5) * 2.5;
+    return (int) (getEnergy(am / 2.5) * 2.5);
   }
 
   @Override
@@ -120,11 +109,6 @@
   }
 
   @Override
-  public int extractEnergy(final ForgeDirection d, final int am, final boolean sim) {
-    return 0;
-  }
-
-  @Override
   public boolean isAddedToEnergyNet() {
     return true;
   }
--- a/com/yogpc/mc_lib/BlockWorkbench.java
+++ b/com/yogpc/mc_lib/BlockWorkbench.java
@@ -22,7 +22,12 @@
     setHardness(3F);
     setCreativeTab(CreativeTabs.tabRedstone);
     setUnlocalizedName("WorkbenchPlus");
-    setTextureName("yogpstop_qp:workbench");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:workbench");
   }
 
   @Override
--- a/com/yogpc/mc_lib/YogpstopLib.java
+++ b/com/yogpc/mc_lib/YogpstopLib.java
@@ -44,7 +44,7 @@
   private static Block workbench, controller;
   private static Item magicmirror, armor;
 
-  @Mod.EventHandler
+  @Mod.PreInit
   public void preInit(final FMLPreInitializationEvent event) {
     final Configuration cfg = new Configuration(event.getSuggestedConfigurationFile());
     final int[] id = new int[4];
@@ -69,7 +69,7 @@
     }
   }
 
-  private static final Pattern lang = Pattern.compile("assets/(.*)/lang/(.*)\\.lang");
+  private static final Pattern lang = Pattern.compile("mods/(.*)/lang/(.*)\\.lang");
   private static final Pattern format = Pattern.compile("%(\\d+\\$)?[\\d\\.]*[df]");
 
   public static Properties parseLangFile(final InputStream is) {
@@ -129,7 +129,7 @@
     }
   }
 
-  @Mod.EventHandler
+  @Mod.Init
   public void init(final FMLInitializationEvent event) {
     GameRegistry.registerBlock(workbench, "WorkbenchPlus");
     GameRegistry.registerBlock(controller, "yogSC");
--- a/com/yogpc/qp/BlockFrame.java
+++ b/com/yogpc/qp/BlockFrame.java
@@ -23,7 +23,12 @@
     setSides(true, true, true, true, true, true);
     setHardness(0.5F);
     setTickRandomly(true);
-    setTextureName("yogpstop_qp:blockFrame");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:blockFrame");
   }
 
   @Override
--- a/com/yogpc/qp/BlockInfMJSrc.java
+++ b/com/yogpc/qp/BlockInfMJSrc.java
@@ -31,7 +31,12 @@
     setStepSound(soundStoneFootstep);
     setCreativeTab(QuarryPlus.ct);
     setUnlocalizedName("InfMJSrc");
-    setTextureName("portal");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("portal");
   }
 
   @Override
--- a/com/yogpc/qp/BlockPlainPipe.java
+++ b/com/yogpc/qp/BlockPlainPipe.java
@@ -17,7 +17,12 @@
     this.maxX = 0.75;
     this.maxY = 1.0;
     this.maxZ = 0.75;
-    setTextureName("yogpstop_qp:blockPlainPipe");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:blockPlainPipe");
   }
 
   @Override
--- a/com/yogpc/qp/BlockRefinery.java
+++ b/com/yogpc/qp/BlockRefinery.java
@@ -38,7 +38,12 @@
     setHardness(5F);
     setCreativeTab(QuarryPlus.ct);
     setUnlocalizedName("RefineryPlus");
-    setTextureName("yogpstop_qp:refineryDummy");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:refineryDummy");
   }
 
   @Override
@@ -99,7 +104,7 @@
   private static boolean fill(final ITankContainer tank, final ForgeDirection side,
       final EntityPlayer player) {
     final ItemStack current = player.getCurrentEquippedItem();
-    final LiquidStack liquid = LiquidContainerRegistry.getFluidForFilledItem(current);
+    final LiquidStack liquid = LiquidContainerRegistry.getLiquidForFilledItem(current);
     if (liquid != null) {
       final int used = tank.fill(side, liquid, true);
       if (used > 0) {
--- a/com/yogpc/qp/QuarryPlus.java
+++ b/com/yogpc/qp/QuarryPlus.java
@@ -85,7 +85,7 @@
   @ForgeSubscribe
   @SideOnly(Side.CLIENT)
   public void loadTextures(final TextureStitchEvent.Pre evt) {
-    if (evt.map.getTextureType() == 0) {
+    if (evt.map.textureType == 0) {
       final TextureMap map = evt.map;
       RenderEntityLaser.icons = new Icon[4];
       RenderEntityLaser.icons[EntityLaser.DRILL] =
@@ -99,7 +99,7 @@
     }
   }
 
-  @Mod.EventHandler
+  @Mod.PreInit
   public void preInit(final FMLPreInitializationEvent event) {
     final Configuration cfg = new Configuration(event.getSuggestedConfigurationFile());
     final int[] id = new int[13];
@@ -150,7 +150,7 @@
     YogpstopLib.loadLangs(event.getSourceFile());
   }
 
-  @Mod.EventHandler
+  @Mod.Init
   public void init(final FMLInitializationEvent event) {
     GameRegistry.registerItem(itemTool, "qpTool");
     GameRegistry.registerBlock(blockQuarry, ItemBlockQuarry.class, "QuarryPlus");
--- a/com/yogpc/qp/TileBasic.java
+++ b/com/yogpc/qp/TileBasic.java
@@ -232,24 +232,25 @@
     return is1.stackSize - rem;
   }
 
+  private static final Class<?> engcls = ReflectionHelper.getClass("buildcraft.energy.TileEngine");
+
   static void injectToNearTile(final World w, final int x, final int y, final int z,
       final ItemStack is) {
-    final List<IPipeTile> pp = new LinkedList<IPipeTile>();
+    final List<TileEntity> pp = new LinkedList<TileEntity>();
     final List<ForgeDirection> ppd = new LinkedList<ForgeDirection>();
     final List<IInventory> pi = new LinkedList<IInventory>();
     final List<ForgeDirection> pid = new LinkedList<ForgeDirection>();
     for (final ForgeDirection d : ForgeDirection.VALID_DIRECTIONS) {
       final TileEntity t = w.getBlockTileEntity(x + d.offsetX, y + d.offsetY, z + d.offsetZ);
-      if (t instanceof IInventory && !(t instanceof IPowerEmitter)
+      if ((t instanceof IInventory) && (engcls == null || !engcls.isInstance(t))
           && addToIInv((IInventory) t, is, d.getOpposite(), false) > 0) {
         pi.add((IInventory) t);
         pid.add(d.getOpposite());
       }
-      if (t instanceof IPipeTile) {
-        final IPipeTile p = (IPipeTile) t;
-        if (p.getPipeType() != IPipeTile.PipeType.ITEM || !p.isPipeConnected(d.getOpposite()))
+      if (t instanceof IPipeEntry && ((IPipeEntry) t).acceptItems()) {
+        if (t instanceof IPipeConnection && !((IPipeConnection) t).isPipeConnected(d.getOpposite()))
           continue;
-        pp.add(p);
+        pp.add(t);
         ppd.add(d.getOpposite());
       }
     }
@@ -258,10 +259,11 @@
       if (is.stackSize <= 0)
         return;
     }
-    for (int i = 0; i < pp.size(); i++) {
-      is.stackSize -= pp.get(i).injectItem(is, true, ppd.get(i));
-      if (is.stackSize <= 0)
-        return;
+    if (pp.size() > 0) {
+      final int i = w.rand.nextInt(pp.size());
+      ((IPipeEntry) pp.get(i)).entityEntering(is.copy(), ppd.get(i));
+      is.stackSize = 0;
+      return;
     }
   }
 
--- a/com/yogpc/qp/TileInfMJSrc.java
+++ b/com/yogpc/qp/TileInfMJSrc.java
@@ -66,9 +66,9 @@
       } catch (final Exception e) {
       }
       if (te instanceof IPowerReceptor) {
-        final IPowerProvider pr = ((IPowerReceptor) te).getPowerProvider(d.getOpposite());
+        final IPowerProvider pr = ((IPowerReceptor) te).getPowerProvider();
         if (pr != null)
-          pr.receiveEnergy(Type.ENGINE, this.power, d.getOpposite());
+          pr.receiveEnergy(this.power, d.getOpposite());
       }
     }
     this.cInterval = this.interval;
--- a/com/yogpc/qp/TileLaser.java
+++ b/com/yogpc/qp/TileLaser.java
@@ -183,11 +183,11 @@
   }
 
   public static final String[] LASER_TEXTURES = new String[] {
-      new String("yogpstop_qp", "textures/entities/laser_1.png"),
-      new String("yogpstop_qp", "textures/entities/laser_2.png"),
-      new String("yogpstop_qp", "textures/entities/laser_3.png"),
-      new String("yogpstop_qp", "textures/entities/laser_4.png"),
-      new String("yogpstop_qp", "textures/entities/stripes.png")};
+      new String("/mods/yogpstop_qp/textures/entities/laser_1.png"),
+      new String("/mods/yogpstop_qp/textures/entities/laser_2.png"),
+      new String("/mods/yogpstop_qp/textures/entities/laser_3.png"),
+      new String("/mods/yogpstop_qp/textures/entities/laser_4.png"),
+      new String("/mods/yogpstop_qp/textures/entities/stripes.png")};
 
   public String getTexture() {
     final double avg = this.pa / 100;
--- a/com/yogpc/qp/TilePump.java
+++ b/com/yogpc/qp/TilePump.java
@@ -140,7 +140,7 @@
               this.zCoord + fd.offsetZ);
       if (te instanceof ITankContainer)
         for (final String s : this.mapping[fd.ordinal()]) {
-          pZ = this.liquids.indexOf(LiquidDictionary.getLiquidStack(s, 0));
+          pZ = this.liquids.indexOf(LiquidDictionary.getCanonicalLiquid(s));
           if (pZ == -1)
             continue;
           fs = this.liquids.get(pZ);
@@ -521,7 +521,7 @@
       for (int i = 0; i < this.liquids.size(); i++)
         ret[i + 1] =
             new StringBuilder().append("    ")
-                .append(this.liquids.get(i).getFluid().getLocalizedName()).append(": ")
+                .append(LiquidDictionary.findLiquidName(this.liquids.get(i))).append(": ")
                 .append(this.liquids.get(i).amount).append("mB").toString();
     } else
       ret[0] = StatCollector.translateToLocal("chat.pumpcontainno");
@@ -553,6 +553,10 @@
   }
 
   @Override
+  public LiquidStack drain(final int id, final int maxDrain, final boolean doDrain) {
+    return null;// TODO
+  }
+
   public LiquidStack drain(final ForgeDirection fd, final LiquidStack resource, final boolean doDrain) {
     if (resource == null)
       return null;
@@ -574,13 +578,8 @@
   }
 
   @Override
-  public boolean canFill(final ForgeDirection from, final Fluid fluid) {
-    return false;
-  }
-
-  @Override
-  public boolean canDrain(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public int fill(final int id, final LiquidStack resource, final boolean doFill) {
+    return 0;
   }
 
   @Override
@@ -590,8 +589,8 @@
     final LinkedList<LiquidTank> ret = new LinkedList<LiquidTank>();
     if (this.mapping[fd.ordinal()].size() <= 0) {
       if (this.liquids.size() <= 0)
-        for (final Integer i : LiquidDictionary.getLiquids().values())
-          ret.add(new LiquidTank(new LiquidStack(i.intValue(), 0), Integer.MAX_VALUE));
+        for (final LiquidStack i : LiquidDictionary.getLiquids().values())
+          ret.add(new LiquidTank(i, Integer.MAX_VALUE));
       else
         for (final LiquidStack fs : this.liquids)
           ret.add(new LiquidTank(fs, Integer.MAX_VALUE));
@@ -599,7 +598,7 @@
       int index;
       LiquidStack fs;
       for (final String s : this.mapping[fd.ordinal()]) {
-        fs = LiquidDictionary.getLiquidStack(s, 0);
+        fs = LiquidDictionary.getCanonicalLiquid(s);
         if (fs == null)
           continue;
         index = this.liquids.indexOf(fs);
@@ -613,6 +612,16 @@
   }
 
   @Override
+  public ILiquidTank getTank(final ForgeDirection d, final LiquidStack t) {
+    final ILiquidTank[] ilda = getTanks(d);
+    if (ilda == null) return null;
+    if (t == null) return ilda[0];
+    for (final ILiquidTank ild : ilda)
+      if (ild.getLiquid().isLiquidEqual(t)) return ild;
+    return null;
+  }
+
+  @Override
   public LiquidStack drain(final ForgeDirection fd, final int maxDrain, final boolean doDrain) {
     if (fd.ordinal() < 0 || fd.ordinal() >= this.mapping.length)
       return drain(ForgeDirection.UP, maxDrain, doDrain);
@@ -624,7 +633,7 @@
     int index;
     LiquidStack fs;
     for (final String s : this.mapping[fd.ordinal()]) {
-      fs = LiquidDictionary.getLiquidStack(s, maxDrain);
+      fs = LiquidDictionary.getLiquid(s, maxDrain);
       if (fs == null)
         continue;
       index = this.liquids.indexOf(fs);
@@ -647,7 +656,7 @@
   static final boolean isLiquid(final Block b, final boolean s, final World w, final int x,
       final int y, final int z, final int m) {
     if (b instanceof ILiquid)
-      return !s || ((ILiquid) b).canDrain(w, x, y, z);
+      return !s || ((ILiquid) b).stillLiquidMeta() == m;
     if (b == Block.waterStill || b == Block.waterMoving || b == Block.lavaStill
         || b == Block.lavaMoving)
       return !s || m == 0;
@@ -663,15 +672,12 @@
     if (isLiquid(b, false, null, 0, 0, 0, 0)) {
       LiquidStack fs = null;
       if (b instanceof ILiquid
-          && ((ILiquid) b).canDrain(this.worldObj, bx + this.xOffset, this.py, bz
-              + this.zOffset))
-        fs =
-            ((ILiquid) b).drain(this.worldObj, bx + this.xOffset, this.py, bz + this.zOffset,
-                true);
+          && ((ILiquid) b).stillLiquidMeta() == meta)
+        fs = new LiquidStack(((ILiquid) b).stillLiquidId(), LiquidContainerRegistry.BUCKET_VOLUME, ((ILiquid) b).stillLiquidMeta());
       else if ((b == Block.waterStill || b == Block.waterMoving) && meta == 0)
-        fs = new LiquidStack(LiquidDictionary.WATER, LiquidContainerRegistry.BUCKET_VOLUME);
+        fs = new LiquidStack(Block.waterStill, LiquidContainerRegistry.BUCKET_VOLUME);
       else if ((b == Block.lavaStill || b == Block.lavaMoving) && meta == 0)
-        fs = new LiquidStack(LiquidDictionary.LAVA, LiquidContainerRegistry.BUCKET_VOLUME);
+        fs = new LiquidStack(Block.lavaStill, LiquidContainerRegistry.BUCKET_VOLUME);
       if (fs != null) {
         final int index = this.liquids.indexOf(fs);
         if (index != -1)
@@ -722,7 +728,13 @@
   public void doWork() {}
 
   @Override
-  public World getWorld() {
-    return this.worldObj;
+  public void setPowerProvider(final IPowerProvider provider) {
+    return;
+  }
+
+  @Override
+  public int powerRequest(final ForgeDirection d) {
+    final TileBasic tb = G_connected();
+    return tb == null ? 0 : tb.powerRequest(d);
   }
 }
--- a/com/yogpc/qp/TileRefinery.java
+++ b/com/yogpc/qp/TileRefinery.java
@@ -238,7 +238,6 @@
     return 0;
   }
 
-  @Override
   public LiquidStack drain(final ForgeDirection from, final LiquidStack resource,
       final boolean doDrain) {
     // if (resource == null) return null;
@@ -282,13 +281,13 @@
   }
 
   @Override
-  public boolean canFill(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public int fill(final int i, final LiquidStack f, final boolean d) {
+    return fill(ForgeDirection.UNKNOWN, f, d);
   }
 
   @Override
-  public boolean canDrain(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public LiquidStack drain(final int i, final int x, final boolean d) {
+    return drain(ForgeDirection.UNKNOWN, x, d);
   }
 
   @Override
@@ -298,6 +297,15 @@
   }
 
   @Override
+  public ILiquidTank getTank(final ForgeDirection direction, final LiquidStack type) {
+    if (type == null) return null;
+    if (type.isLiquidEqual(this.src1)) return new LiquidTank(this.src1, this.buf);
+    if (type.isLiquidEqual(this.src2)) return new LiquidTank(this.src2, this.buf);
+    if (type.isLiquidEqual(this.res)) return new LiquidTank(this.res, this.buf);
+    return null;
+  }
+
+  @Override
   public byte getEfficiency() {
     return this.efficiency;
   }
--- a/com/yogpc/qp/client/GuiInfMJSrc.java
+++ b/com/yogpc/qp/client/GuiInfMJSrc.java
@@ -31,8 +31,7 @@
 
 @SideOnly(Side.CLIENT)
 public class GuiInfMJSrc extends GuiScreenA {
-  private static final String gui = new String("yogpstop_qp",
-      "textures/gui/infmjsrc.png");
+  private static final String gui = "/mods/yogpstop_qp/textures/gui/infmjsrc.png";
   private final TileInfMJSrc tile;
   private GuiTextField eng;
   private GuiTextField itv;
--- a/com/yogpc/qp/client/GuiMover.java
+++ b/com/yogpc/qp/client/GuiMover.java
@@ -31,8 +31,7 @@
 @SideOnly(Side.CLIENT)
 public class GuiMover extends GuiContainer {
   public GuiButton b32, b33, b34, b35;
-  private static final String gui = new String("yogpstop_qp",
-      "textures/gui/mover.png");
+  private static final String gui = "/mods/yogpstop_qp/textures/gui/mover.png";
 
   public GuiMover(final EntityPlayer player, final World world, final int x, final int y,
       final int z) {
--- a/com/yogpc/qp/client/GuiP_List.java
+++ b/com/yogpc/qp/client/GuiP_List.java
@@ -90,9 +90,7 @@
         this.mc.displayGuiScreen(new GuiP_SelectSide(this.tile, this, par1.id == -5));
         break;
       case PacketHandler.CtS_REMOVE_MAPPING:
-        String name = this.tile.mapping[this.dir].get(this.oreslot.currentore);
-        if (LiquidDictionary.isFluidRegistered(name))
-          name = LiquidDictionary.getFluid(name).getLocalizedName();
+        final String name = this.tile.mapping[this.dir].get(this.oreslot.currentore);
         this.mc.displayGuiScreen(new GuiYesNo(this, StatCollector
             .translateToLocal("tof.deletefluidsure"), name, par1.id));
         break;
--- a/com/yogpc/qp/client/GuiP_Manual.java
+++ b/com/yogpc/qp/client/GuiP_Manual.java
@@ -50,18 +50,14 @@
   public void actionPerformed(final GuiButton par1) {
     switch (par1.id) {
       case -1:
-        String name = this.blockid.getText();
+        final String name = this.blockid.getText();
         if (name.length() == 0)
           return;
         if (this.tile.mapping[this.targetid].contains(name)) {
-          if (LiquidDictionary.isFluidRegistered(name))
-            name = LiquidDictionary.getFluid(name).getLocalizedName();
           this.mc.displayGuiScreen(new GuiError(this, StatCollector
               .translateToLocal("tof.alreadyerror"), name));
           return;
         }
-        if (LiquidDictionary.isFluidRegistered(name))
-          name = LiquidDictionary.getFluid(name).getLocalizedName();
         this.mc.displayGuiScreen(new GuiYesNo(this, StatCollector
             .translateToLocal("tof.addfluidsure"), name, -1));
         break;
--- a/com/yogpc/qp/client/GuiP_SlotBlockList.java
+++ b/com/yogpc/qp/client/GuiP_SlotBlockList.java
@@ -74,7 +74,7 @@
 
   @Override
   protected void drawSlot(final int var1, final int var2, final int var3, final int var4, final Tessellator var5) {
-    final String name = LiquidDictionary.getFluid(this.blocklist.get(var1)).getLocalizedName();
+    final String name = this.blocklist.get(var1);
     Minecraft.getMinecraft().fontRenderer.drawStringWithShadow(name,
         (this.parent.width - Minecraft.getMinecraft().fontRenderer.getStringWidth(name)) / 2,
         var3 + 1, 0xFFFFFF);
--- a/com/yogpc/qp/client/GuiP_SlotList.java
+++ b/com/yogpc/qp/client/GuiP_SlotList.java
@@ -58,9 +58,7 @@
 
   @Override
   protected void drawSlot(final int var1, final int var2, final int var3, final int var4, final Tessellator var5) {
-    String name = this.target.get(var1);
-    if (LiquidDictionary.isFluidRegistered(name))
-      name = LiquidDictionary.getFluid(name).getLocalizedName();
+    final String name = this.target.get(var1);
     Minecraft.getMinecraft().fontRenderer
         .drawStringWithShadow(
             name,
--- a/com/yogpc/qp/client/RenderEntityLaser.java
+++ b/com/yogpc/qp/client/RenderEntityLaser.java
@@ -23,11 +23,6 @@
   private RenderEntityLaser() {}
 
   @Override
-  protected String getEntityTexture(final Entity entity) {
-    return TextureMap.locationBlocksTexture;
-  }
-
-  @Override
   public void doRender(final Entity e, final double i, final double j, final double k,
       final float f, final float f1) {
     if (e.isDead)
@@ -56,7 +51,7 @@
       final double k, final double iSize, final double jSize, final double kSize, final int tex) {
     GL11.glPushMatrix();
     GL11.glTranslated(i, j, k);
-    tm.bindTexture(TextureMap.locationBlocksTexture);
+    tm.bindTexture("/terrain.png");
     final Tessellator t = Tessellator.instance;
     final RenderBlocks rb = new RenderBlocks();
     for (int iBase = 0; iBase < iSize; ++iBase)
--- a/com/yogpc/qp/client/RenderRefinery.java
+++ b/com/yogpc/qp/client/RenderRefinery.java
@@ -41,8 +41,7 @@
 @SideOnly(Side.CLIENT)
 public class RenderRefinery extends TileEntitySpecialRenderer implements
     ISimpleBlockRenderingHandler {
-  private static final String TEXTURE = new String("yogpstop_qp",
-      "textures/blocks/refinery.png");
+  private static final String TEXTURE = "/mods/yogpstop_qp/textures/blocks/refinery.png";
   private static final float pixel = (float) (1.0 / 16.0);
   private static final RenderBlocks renderBlocks = new RenderBlocks();
   public static final RenderRefinery INSTANCE = new RenderRefinery();
@@ -112,7 +111,7 @@
 
     GL11.glRotatef(angle, 0, 1, 0);
 
-    bindTexture(TEXTURE);
+    bindTextureByName(TEXTURE);
 
     GL11.glPushMatrix();
     GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
@@ -179,8 +178,9 @@
           GL11.glPushMatrix();
           GL11.glTranslatef(tx, ty, tz);
         }
-        bindTexture(TextureMap.locationBlocksTexture);
-        setColor(liquid.getFluid().getColor(liquid));
+        bindTextureByName(liquid.getTextureSheet());
+        final ItemStack stack = liquid.asItemStack();
+        setColor(stack.getItem().getColorFromItemStack(stack, 0));
         GL11.glCallList(list[(int) (liquid.amount / buf * 99)]);
         if (tx != 0 || ty != 0 || tz != 0)
           GL11.glPopMatrix();
@@ -188,25 +188,22 @@
     }
   }
 
-  private static final Map<Fluid, int[]> stillRenderCache = new HashMap<Fluid, int[]>();
+  private static final Map<LiquidStack, int[]> stillRenderCache = new HashMap<LiquidStack, int[]>();
 
   private static int[] getLiquidDisplayLists(final LiquidStack fluidStack) {
-    final Fluid fluid = fluidStack.getFluid();
-    if (fluid == null)
-      return null;
-    final Map<Fluid, int[]> cache = stillRenderCache;
-    int[] diplayLists = cache.get(fluid);
+    final Map<LiquidStack, int[]> cache = stillRenderCache;
+    int[] diplayLists = cache.get(fluidStack);
     if (diplayLists != null)
       return diplayLists;
     diplayLists = new int[100];
     Block baseBlock;
     Icon texture;
-    if (fluid.getBlockID() > -1) {
-      baseBlock = Block.blocksList[fluid.getBlockID()];
-      texture = fluid.getStillIcon();
+    if (fluidStack.itemID > -1) {
+      baseBlock = Block.blocksList[fluidStack.itemID];
+      texture = fluidStack.getRenderingIcon();
     } else {
       baseBlock = Block.waterStill;
-      texture = fluid.getStillIcon();
+      texture = fluidStack.getRenderingIcon();
     }
     GL11.glDisable(GL11.GL_LIGHTING);
     GL11.glDisable(GL11.GL_BLEND);
@@ -236,7 +233,7 @@
     GL11.glEnable(GL11.GL_CULL_FACE);
     GL11.glEnable(GL11.GL_BLEND);
     GL11.glEnable(GL11.GL_LIGHTING);
-    cache.put(fluid, diplayLists);
+    cache.put(fluidStack, diplayLists);
     return diplayLists;
   }
 
